package io.sentry.android.gradle.snapshot.codegen

/**
 * Contains the template for the single generated test file. The file is always identical — it reads
 * a JSON config at test runtime to determine which composables to snapshot.
 */
internal object SnapshotTestTemplate {

  const val PACKAGE_NAME = "io.sentry.android.snapshot.generated"
  const val CLASS_NAME = "SentrySnapshotTest"

  @Suppress("MaxLineLength")
  val content: String
    get() =
      """
// Generated by Sentry Snapshot Plugin — do not edit
package $PACKAGE_NAME

import androidx.compose.runtime.Composable
import androidx.compose.runtime.currentComposer
import app.cash.paparazzi.Paparazzi
import java.io.File
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.Parameterized

@RunWith(Parameterized::class)
class $CLASS_NAME(
    private val displayName: String,
    private val className: String,
    private val methodName: String,
) {
    @get:Rule
    val paparazzi = Paparazzi()

    @Test
    fun snapshot() {
        paparazzi.snapshot(name = displayName) {
            InvokePreview(className, methodName)
        }
    }

    companion object {
        @JvmStatic
        @Parameterized.Parameters(name = "{0}")
        fun previews(): List<Array<String>> {
            val configFile = System.getProperty("sentry.snapshot.configFile")
                ?: error("sentry.snapshot.configFile system property not set")
            return parseConfigs(File(configFile).readText())
        }

        private fun parseConfigs(json: String): List<Array<String>> {
            val results = mutableListOf<Array<String>>()
            var pos = 0
            while (true) {
                val start = json.indexOf('{', pos)
                if (start == -1) break
                val end = json.indexOf('}', start)
                if (end == -1) break
                val fields = parseFields(json.substring(start + 1, end))
                val dn = fields["displayName"]
                val cn = fields["className"]
                val mn = fields["methodName"]
                if (dn != null && cn != null && mn != null) {
                    results.add(arrayOf(dn, cn, mn))
                }
                pos = end + 1
            }
            return results
        }

        private fun parseFields(obj: String): Map<String, String> {
            val fields = mutableMapOf<String, String>()
            var i = 0
            while (i < obj.length) {
                val ks = obj.indexOf('"', i)
                if (ks == -1) break
                val ke = obj.indexOf('"', ks + 1)
                if (ke == -1) break
                val key = obj.substring(ks + 1, ke)
                val vs = obj.indexOf('"', ke + 1)
                if (vs == -1) break
                val ve = findClosingQuote(obj, vs + 1)
                fields[key] = unescapeJson(obj.substring(vs + 1, ve))
                i = ve + 1
            }
            return fields
        }

        private fun findClosingQuote(s: String, start: Int): Int {
            var i = start
            while (i < s.length) {
                if (s[i] == '\\' && i + 1 < s.length) { i += 2; continue }
                if (s[i] == '"') return i
                i++
            }
            return s.length
        }

        private fun unescapeJson(s: String): String {
            if (!s.contains('\\')) return s
            val sb = StringBuilder(s.length)
            var i = 0
            while (i < s.length) {
                if (s[i] == '\\' && i + 1 < s.length) {
                    when (s[i + 1]) {
                        '"' -> sb.append('"')
                        '\\' -> sb.append('\\')
                        'n' -> sb.append('\n')
                        't' -> sb.append('\t')
                        'r' -> sb.append('\r')
                        else -> { sb.append('\\'); sb.append(s[i + 1]) }
                    }
                    i += 2
                } else {
                    sb.append(s[i])
                    i++
                }
            }
            return sb.toString()
        }
    }
}

@Composable
private fun InvokePreview(className: String, methodName: String) {
    val clazz = Class.forName(className)
    val method = clazz.declaredMethods.firstOrNull { m ->
        m.name == methodName &&
        m.parameterTypes.size == 2 &&
        m.parameterTypes[0].name.endsWith("Composer") &&
        m.parameterTypes[1] == Int::class.javaPrimitiveType
    } ?: error("Composable ${'$'}className.${'$'}methodName not found")
    method.isAccessible = true
    method.invoke(null, currentComposer, 0)
}
"""
        .trimIndent()
}
